<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>理解数据库事务 - Mr.SymbolのBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Mr.Symbolのblog"><meta name="msapplication-TileImage" content="/img/s2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Mr.Symbolのblog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="理解数据库事务：ACID、隔离级别、数据库并发问题、并发问题的解决（锁）、MVCC"><meta property="og:type" content="blog"><meta property="og:title" content="理解数据库事务"><meta property="og:url" content="http://symbol23441.top/2025/04/09/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"><meta property="og:site_name" content="Mr.SymbolのBlog"><meta property="og:description" content="理解数据库事务：ACID、隔离级别、数据库并发问题、并发问题的解决（锁）、MVCC"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://symbol23441.top/img/og_image.png"><meta property="article:published_time" content="2025-04-09T12:28:40.000Z"><meta property="article:modified_time" content="2025-04-09T12:28:40.000Z"><meta property="article:author" content="Mr.Symbol"><meta property="article:tag" content="数据库"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://symbol23441.top/2025/04/09/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"},"headline":"理解数据库事务","image":["http://symbol23441.top/img/og_image.png"],"datePublished":"2025-04-09T12:28:40.000Z","dateModified":"2025-04-09T12:28:40.000Z","author":{"@type":"Person","name":"Mr.Symbol"},"publisher":{"@type":"Organization","name":"Mr.SymbolのBlog","logo":{"@type":"ImageObject","url":{"text":"Mr.SymbolのBlog"}}},"description":"理解数据库事务：ACID、隔离级别、数据库并发问题、并发问题的解决（锁）、MVCC"}</script><link rel="canonical" href="http://symbol23441.top/2025/04/09/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"><link rel="icon" href="/img/s2.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Mr.SymbolのBlog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-09T12:28:40.000Z" title="4/9/2025, 8:28:40 PM">2025-04-09</time>发表</span><span class="level-item"><time dateTime="2025-04-09T12:28:40.000Z" title="4/9/2025, 8:28:40 PM">2025-04-09</time>更新</span><span class="level-item">28 分钟读完 (大约4255个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">理解数据库事务</h1><div class="content"><p>理解数据库事务：ACID、隔离级别、数据库并发问题、并发问题的解决（锁）、MVCC</p>
<span id="more"></span>

<h2 id="一、ACID：事务的四大特性"><a href="#一、ACID：事务的四大特性" class="headerlink" title="一、ACID：事务的四大特性"></a>一、ACID：事务的四大特性</h2><blockquote>
<p>数据库事务的设计目标是：让一组操作，要么全部成功，要么全部失败，保证数据的<strong>一致性与可靠性</strong>。</p>
</blockquote>
<h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><ul>
<li>事务中的所有操作应该被看作不可分割的一组指令，任何一个指令不能独立存在，要么全部成功执行，要么全部不发生（也就是回滚）</li>
<li>原子性并不意味着中间操作无法失败，而是：失败后必须<strong>整体回滚</strong>，不留下脏数据。程序员也可以主动调用 <code>rollback()</code> 实现业务层回滚。</li>
</ul>
<blockquote>
<p>举例：用户下单后扣库存失败，整个下单过程需要撤销。</p>
</blockquote>
<hr>
<h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><ul>
<li>一致性是指事务是否产生非预期中间状态或结果。如脏读、不可重复度等，出现了非预期的中间状态。</li>
<li> 一致性实际上是由后面的隔离性去进一步保证的，隔离性达到要求，则可以满足一致性。也就是说，隔离不足会导致事务不满足一致性要求，所以务必理解各个隔离级别，才能少写Bug。</li>
</ul>
<hr>
<h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><ul>
<li>隔离性就是<code>多个事务互不影响，感觉不到对方存在</code>，这个特性就是为了做并发控制。</li>
<li>不同隔离级别对应不同的并发场景，隔离性越高，性能越低。最理想的效果是可串行化，目前采用两阶段加锁的方式，但是效率非常低。</li>
</ul>
<p>有时候为了效率，原则是可以妥协的，于是隔离性并不严格，它被分为了多种级别，从高到低分别为：</p>
<ul>
<li>⬇️可串行化（Serializable）</li>
<li>⬇️可重复读（Read Repeatable）</li>
<li>⬇️已提交读（Read Committed）</li>
<li>⬇️未提交读（Read Uncommitted）</li>
</ul>
<blockquote>
<p>举例：两个用户同时抢购商品，不应互相看到对方的中间状态。</p>
</blockquote>
<hr>
<h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><ul>
<li>✅ 一旦事务提交，修改就会<strong>永久保存</strong>，即使宕机也不会丢失。</li>
<li>⚙️ 依赖数据库的日志机制（如 redo log）。</li>
</ul>
<blockquote>
<p>举例：下单成功后即使断电，订单数据仍然保留。</p>
</blockquote>
<h2 id="二、事务隔离级别详解"><a href="#二、事务隔离级别详解" class="headerlink" title="二、事务隔离级别详解"></a>二、事务隔离级别详解</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（Read Uncommitted，RU）</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>已提交读（Read Committed，RC）</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>可重复读（Read Repeatable，RR）</td>
<td>❌</td>
<td>❌</td>
<td>✅（用间隙锁防）</td>
</tr>
<tr>
<td>可串行化（Serializable）</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="三、并发问题"><a href="#三、并发问题" class="headerlink" title="三、并发问题"></a>三、并发问题</h2><h3 id="1-脏读（Dirty-Read）"><a href="#1-脏读（Dirty-Read）" class="headerlink" title="1. 脏读（Dirty Read）"></a>1. 脏读（Dirty Read）</h3><blockquote>
<p>一个事务读到了另一个未提交事务的数据。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A（此时读取了事务 B 尚未提交的数据）</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 读取到了 -100 的余额</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B 回滚</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A 的读取结果是脏的，不存在的数据</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-脏写（Dirty-Write）"><a href="#2-脏写（Dirty-Write）" class="headerlink" title="2. 脏写（Dirty Write）"></a>2. 脏写（Dirty Write）</h3><blockquote>
<p>两个未提交的事务修改了同一行数据，后提交的会覆盖前者。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">200</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B（在 A 未提交时也修改同一数据）</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">300</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A 提交（balance = 200）</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B 提交（balance = 300，A 的修改被“擦除”）</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>💡 数据库通常通过加 <strong>排他锁</strong> 防止这种情况发生。</p>
<hr>
<h3 id="3-不可重复读（Non-Repeatable-Read）"><a href="#3-不可重复读（Non-Repeatable-Read）" class="headerlink" title="3. 不可重复读（Non-Repeatable Read）"></a>3. 不可重复读（Non-Repeatable Read）</h3><blockquote>
<p>同一事务两次读同一条数据，结果不同。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> price <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 结果：100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE product <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">200</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A 再次读取</span></span><br><span class="line"><span class="keyword">SELECT</span> price <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 结果：200（变了！）</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-幻读（Phantom-Read）"><a href="#4-幻读（Phantom-Read）" class="headerlink" title="4. 幻读（Phantom Read）"></a>4. 幻读（Phantom Read）</h3><blockquote>
<p>两次相同条件的范围查询，结果条数不同。</p>
</blockquote>
<p>相比不可重复读来说，不是具体某条记录的内容，而是范围性的，如记录个数等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;  <span class="comment">-- 返回：3 条记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B 插入符合条件的数据</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A 再次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;  <span class="comment">-- 返回：4 条记录（幻读）</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>💡 RR 隔离级别通过间隙锁可以防止这种插入。</p>
<hr>
<h3 id="5-读偏差（Read-Skew）"><a href="#5-读偏差（Read-Skew）" class="headerlink" title="5. 读偏差（Read Skew）"></a>5. 读偏差（Read Skew）</h3><blockquote>
<p><strong>读偏差</strong>（Read Skew）是一种事务并发异常，指的是<strong>在一个事务中读取多个相关数据时，部分数据已被其他事务修改并提交，导致读出的整体状态不一致，违反了业务逻辑上的一致性。</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始状态：账户 A = 50, 账户 B = 50，总和应为 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;  <span class="comment">-- 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B：把 A 的余额转给 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A 继续读</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;  <span class="comment">-- 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- A 读到的总额为：50 + 100 = 150（读偏差）</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-写偏差（Write-Skew）"><a href="#6-写偏差（Write-Skew）" class="headerlink" title="6. 写偏差（Write Skew）"></a>6. 写偏差（Write Skew）</h3><blockquote>
<p><strong>写偏差（Write Skew）</strong>，又称<strong>写前提困境</strong>，是指事务在提交前所依赖的“读前提”在并发场景中被其他事务改变，但自己却“蒙在鼓里”仍然提交了基于旧前提的写入，最终导致了<strong>业务一致性破坏</strong>。</p>
</blockquote>
<p>📌 特点：</p>
<ul>
<li>写偏差通常发生在：<strong>读取前提和写入目标不是同一条记录</strong></li>
<li>数据库本身不会检测到冲突，只有业务逻辑才知道出错了</li>
</ul>
<h4 id="📋-场景背景："><a href="#📋-场景背景：" class="headerlink" title="📋 场景背景："></a>📋 场景背景：</h4><ul>
<li>用户有会员等级（如 1~3 级），3 级享受 <strong>3 倍积分加成</strong></li>
<li>会员降级条件：积分 &lt; 3000，每日定时任务会检查并降级</li>
<li>积分与等级不是同一字段，不存在主键/唯一约束冲突</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【事务 A：消费刷卡，计算积分】</span><br><span class="line"><span class="number">1.</span> 查询会员等级 <span class="operator">=</span> <span class="number">3</span>（此时积分为 <span class="number">2800</span>，刚好不满足等级条件）</span><br><span class="line"><span class="number">2.</span> 根据 <span class="number">3</span> 倍积分计算，加了 <span class="number">90</span> 分（原价 <span class="number">30</span> <span class="operator">*</span> <span class="number">3</span>）</span><br><span class="line"></span><br><span class="line">【事务 B：定时任务，执行降级】</span><br><span class="line"><span class="number">1.</span> 查询积分 <span class="operator">&lt;</span> <span class="number">3000</span>，满足降级条件</span><br><span class="line"><span class="number">2.</span> 将会员等级从 <span class="number">3</span> → <span class="number">2</span>，更新数据库</span><br><span class="line"><span class="number">3.</span> <span class="keyword">COMMIT</span> ✅</span><br><span class="line"></span><br><span class="line">【事务 A 接着执行】</span><br><span class="line"><span class="number">3.</span> 没意识到等级已降，仍用等级<span class="operator">=</span><span class="number">3</span> 的老数据计算</span><br><span class="line"><span class="number">4.</span> 更新积分 <span class="operator">+</span><span class="number">90</span>，提交 ✅</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-丢失更新（Lost-Update）"><a href="#7-丢失更新（Lost-Update）" class="headerlink" title="7. 丢失更新（Lost Update）"></a>7. 丢失更新（Lost Update）</h3><blockquote>
<p>丢失更新：多个事务<strong>基于相同的旧数据</strong>进行修改，导致后提交的事务覆盖了前者的结果，<strong>前者的修改“丢失”了</strong>。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始值：余额 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 读取 100</span></span><br><span class="line"><span class="comment">-- A 计算：balance + 10 = 110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 读取 100</span></span><br><span class="line"><span class="comment">-- B 计算：balance + 20 = 120</span></span><br><span class="line">UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">120</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A 写入</span></span><br><span class="line">UPDATE account <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">110</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果：最终余额为 110（B 的修改被 A 覆盖，更新丢失）</span></span><br></pre></td></tr></table></figure>

<h3 id="8-并发问题总结"><a href="#8-并发问题总结" class="headerlink" title="8. 并发问题总结"></a>8. 并发问题总结</h3><table>
<thead>
<tr>
<th>编号</th>
<th>并发问题</th>
<th>定义</th>
<th>典型特征</th>
<th>可能后果</th>
<th>解决方式</th>
</tr>
</thead>
<tbody><tr>
<td>①</td>
<td><strong>脏读</strong> Dirty Read</td>
<td>读到<strong>未提交事务的数据</strong></td>
<td>读到了可能会回滚的数据</td>
<td>读到不真实、无效数据</td>
<td>设置隔离级别 ≥ <strong>RC</strong></td>
</tr>
<tr>
<td>②</td>
<td><strong>脏写</strong> Dirty Write</td>
<td>两个未提交事务修改同一数据</td>
<td>后提交者<strong>擦除</strong>前者写入</td>
<td>数据被不正确覆盖</td>
<td>数据库默认禁用；加<strong>排它锁</strong></td>
</tr>
<tr>
<td>③</td>
<td><strong>不可重复读</strong> Non-Repeatable Read</td>
<td>同一事务两次读同一条记录，结果不同</td>
<td>同一记录值发生变化</td>
<td>逻辑判断出错、缓存失效</td>
<td>设置隔离级别 ≥ <strong>RR</strong>（MVCC）</td>
</tr>
<tr>
<td>④</td>
<td><strong>幻读</strong> Phantom Read</td>
<td>两次<strong>范围查询</strong>，结果记录数不同</td>
<td>记录条数变化</td>
<td>插入了意料之外的行</td>
<td>RR + <strong>间隙锁（Gap Lock）</strong> or <strong>Serializable</strong></td>
</tr>
<tr>
<td>⑤</td>
<td><strong>读偏差</strong> Read Skew</td>
<td>跨多条记录读到不一致状态</td>
<td>总和、组合值异常</td>
<td>违反业务一致性（如转账总额不对）</td>
<td><strong>Serializable</strong> or 显式加锁</td>
</tr>
<tr>
<td>⑥</td>
<td><strong>写偏差</strong> Write Skew</td>
<td>基于旧的读前提，写入已不成立的修改</td>
<td>各自写不同字段，看似不冲突实则冲突</td>
<td>破坏业务规则，如“两人不能同时上岗”</td>
<td>Serializable / 显式加锁 / 前提校验</td>
</tr>
<tr>
<td>⑦</td>
<td><strong>丢失更新</strong> Lost Update</td>
<td>并发事务读同一值修改并提交，<strong>后者覆盖前者</strong></td>
<td>前者结果丢失</td>
<td>结果不正确（如充值金额少了）</td>
<td>乐观锁、悲观锁、自增操作、CAS</td>
</tr>
</tbody></table>
<p>1-4是由于对单条数据的并发问题，5-7是多个数据业务相互依赖，从业务逻辑上导致的并发问题。</p>
<h2 id="四、基于锁的隔离级别实现"><a href="#四、基于锁的隔离级别实现" class="headerlink" title="四、基于锁的隔离级别实现"></a>四、基于锁的隔离级别实现</h2><h3 id="1、为什么需要锁？"><a href="#1、为什么需要锁？" class="headerlink" title="1、为什么需要锁？"></a>1、为什么需要锁？</h3><p>在数据库事务中，我们期望多条 SQL 组成一个“原子操作”，在并发环境下也能保持一致性和可靠性。然而，多个事务同时操作数据库会带来各种并发问题，比如：</p>
<ul>
<li>脏读、脏写</li>
<li>不可重复读</li>
<li>幻读、写偏差、丢失更新</li>
</ul>
<p>为了解决这些问题，我们需要一种机制来控制并发访问 —— <strong>锁</strong>。</p>
<h3 id="2、基础锁类型"><a href="#2、基础锁类型" class="headerlink" title="2、基础锁类型"></a>2、基础锁类型</h3><h4 id="（1）共享锁（S锁，Share-Lock）"><a href="#（1）共享锁（S锁，Share-Lock）" class="headerlink" title="（1）共享锁（S锁，Share Lock）"></a>（1）共享锁（S锁，Share Lock）</h4><ul>
<li>只允许<strong>读</strong>，不允许写。</li>
<li>多个事务可以同时持有同一条记录的共享锁。</li>
<li>适用于 SELECT 等读操作。</li>
</ul>
<h4 id="（2）排它锁（X锁，Exclusive-Lock）"><a href="#（2）排它锁（X锁，Exclusive-Lock）" class="headerlink" title="（2）排它锁（X锁，Exclusive Lock）"></a>（2）排它锁（X锁，Exclusive Lock）</h4><ul>
<li>允许<strong>读 + 写</strong>。</li>
<li>一条记录只能被一个事务持有排它锁。</li>
<li>适用于 UPDATE、DELETE 等写操作。</li>
</ul>
<h4 id="（3）锁兼容关系："><a href="#（3）锁兼容关系：" class="headerlink" title="（3）锁兼容关系："></a>（3）锁兼容关系：</h4><table>
<thead>
<tr>
<th>当前锁</th>
<th>S锁</th>
<th>X锁</th>
</tr>
</thead>
<tbody><tr>
<td>S锁</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>X锁</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h3 id="3、两阶段加锁协议（2PL）"><a href="#3、两阶段加锁协议（2PL）" class="headerlink" title="3、两阶段加锁协议（2PL）"></a>3、两阶段加锁协议（2PL）</h3><p>为了实现严格的串行化，需要事务按照以下规则来加锁和解锁：</p>
<h4 id="📌-1-基本两阶段加锁（2PL）"><a href="#📌-1-基本两阶段加锁（2PL）" class="headerlink" title="📌 1. 基本两阶段加锁（2PL）"></a>📌 1. 基本两阶段加锁（2PL）</h4><ul>
<li><strong>加锁阶段</strong>：事务可以随意加锁，不能解锁。</li>
<li><strong>解锁阶段</strong>：开始解锁后，不能再加锁。</li>
</ul>
<h4 id="📌-2-严格两阶段加锁（Strict-2PL）"><a href="#📌-2-严格两阶段加锁（Strict-2PL）" class="headerlink" title="📌 2. 严格两阶段加锁（Strict 2PL）"></a>📌 2. 严格两阶段加锁（Strict 2PL）</h4><ul>
<li>只有在事务<strong>提交或回滚</strong>时，才释放所有锁。</li>
</ul>
<p>✅ 这样可以确保：只要某事务读取或写入了一条记录，其它事务就必须等待它提交或回滚后才能操作该记录，由此实现了可串行化。</p>
<h3 id="4、多粒度锁-amp-意向锁（Intention-Lock）"><a href="#4、多粒度锁-amp-意向锁（Intention-Lock）" class="headerlink" title="4、多粒度锁 &amp; 意向锁（Intention Lock）"></a>4、多粒度锁 &amp; 意向锁（Intention Lock）</h3><h4 id="✅-多粒度锁？"><a href="#✅-多粒度锁？" class="headerlink" title="✅ 多粒度锁？"></a>✅ 多粒度锁？</h4><ul>
<li>表锁：锁住整张表（影响大）</li>
<li>行锁：只锁一条记录（更细粒度，影响小）</li>
</ul>
<p><strong>问题：</strong> 当一个事务要加表级锁时，如何判断是否安全？即这张表中有没有其它事务已经对某些行加锁？</p>
<p><strong>传统方式：</strong> 遍历所有行锁 —— 💣 性能开销大</p>
<h4 id="✅-意向锁的作用"><a href="#✅-意向锁的作用" class="headerlink" title="✅ 意向锁的作用"></a>✅ 意向锁的作用</h4><blockquote>
<p>💡 <strong>意向锁 = 告诉别人“我准备加行锁了”</strong>。相当于表级标记。</p>
</blockquote>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>提示意图</td>
<td>提前在表级“打标记”，告知系统下层将加行锁</td>
</tr>
<tr>
<td>冲突判断</td>
<td>表锁申请前，仅判断表级意向锁是否冲突，<strong>无需遍历所有行锁</strong></td>
</tr>
</tbody></table>
<p><strong>意向锁</strong>：</p>
<p>意向共享锁（Intention Shared，IS），表示将要对某些记录加 <strong>共享锁</strong>（读）。</p>
<p>意向排他锁（Intention Exclusive，IX），表示将要对某些记录加<strong>排他锁</strong>（写）。</p>
<h4 id="✅-加锁顺序与兼容"><a href="#✅-加锁顺序与兼容" class="headerlink" title="✅  加锁顺序与兼容"></a>✅  <strong>加锁顺序与兼容</strong></h4><blockquote>
<p>加行锁之前 ， 先加对应的意向锁：</p>
</blockquote>
<ul>
<li>加IS 表锁 ➜  加 S 行锁</li>
</ul>
<p><strong>意向锁锁兼容性</strong>：意向锁间是相互容的，与X、S同X、S关系一致。</p>
<p>例子：</p>
<table>
<thead>
<tr>
<th>事务</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>想对某行加行级 X 锁 → 表上先加 IX 锁</td>
</tr>
<tr>
<td>B</td>
<td>想对整张表加表级 X 锁 → 发现表上已有 IX 锁 → <strong>冲突，需等待</strong></td>
</tr>
</tbody></table>
<h3 id="5、解决幻读：间隙锁-amp-Next-Key-Lock"><a href="#5、解决幻读：间隙锁-amp-Next-Key-Lock" class="headerlink" title="5、解决幻读：间隙锁 &amp; Next-Key Lock"></a>5、解决幻读：间隙锁 &amp; Next-Key Lock</h3><h4 id="幻读场景："><a href="#幻读场景：" class="headerlink" title="幻读场景："></a>幻读场景：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>再次查询时，A发现多了一条记录“Tom”，即发生幻读。</p>
<h4 id="1-间隙锁（Gap-Lock）"><a href="#1-间隙锁（Gap-Lock）" class="headerlink" title="1. 间隙锁（Gap Lock）"></a>1. 间隙锁（Gap Lock）</h4><ul>
<li>锁住<strong>两条记录之间的间隙</strong>，阻止插入。</li>
<li>不锁记录本身，只防止“新的记录”插入指定范围。</li>
</ul>
<h4 id="2-Next-Key-Lock"><a href="#2-Next-Key-Lock" class="headerlink" title="2. Next-Key Lock"></a>2. Next-Key Lock</h4><ul>
<li>是<strong>记录锁 + 间隙锁</strong>的组合，锁定一个前开后闭区间 <code>(a, b]</code>。</li>
<li>防止插入 + 防止更新，效果更强。</li>
</ul>
<p>InnoDB 使用 Next-Key Lock，实质上Next-Key Lock目的仅为减少锁表存储空间。</p>
<h3 id="6、并发问题的锁解决方案"><a href="#6、并发问题的锁解决方案" class="headerlink" title="6、并发问题的锁解决方案"></a>6、并发问题的锁解决方案</h3><p>基于严格两阶段锁，读前共享锁，写前排他所，可以解决所有并发问题，属于InnoDB中的串行化级别。</p>
<p>1-3易理解，4幻读采用间隙锁解决，5-7，因为读前共享锁、写前排他锁，防止了陈旧数据的出现，因此避免了问题。</p>
<h2 id="五、MVCC"><a href="#五、MVCC" class="headerlink" title="五、MVCC"></a>五、MVCC</h2><h3 id="1、引入MVCC的动机"><a href="#1、引入MVCC的动机" class="headerlink" title="1、引入MVCC的动机"></a>1、引入MVCC的动机</h3><p>基于严格二阶段加锁+XS锁的方式可实现串行化隔离级别。但现实中，某些业务<strong>读多写少</strong>，传统的锁方案并发效率低。</p>
<p>为了提升 <strong>读性能</strong>，并且在不牺牲一致性的前提下避免加锁带来的性能问题，数据库引入了 <strong>MVCC</strong>（Multi-Version Concurrency Control，多版本并发控制）：</p>
<blockquote>
<p>在不加锁的前提下，让读取操作能看到一个一致的数据快照，避免读阻塞写，写也不阻塞读。</p>
</blockquote>
<h3 id="2、MVCC-的底层机制"><a href="#2、MVCC-的底层机制" class="headerlink" title="2、MVCC 的底层机制"></a>2、MVCC 的底层机制</h3><p>MVCC 的实现依赖两个核心结构：<strong>版本链（Undo Log）</strong>、<strong>快照视图（Read View）</strong>。</p>
<h4 id="1-版本链（Undo-Log）"><a href="#1-版本链（Undo-Log）" class="headerlink" title="1. 版本链（Undo Log）"></a>1. 版本链（Undo Log）</h4><p>每次对记录的更新（UPDATE / DELETE），都不会直接覆盖数据，而是把老版本保存在 Undo Log 中，并<strong>通过一个链条结构串联起来</strong>。</p>
<p>📌 每条记录都多了两个隐藏字段：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>trx_id</code></td>
<td>创建该版本的事务 ID</td>
</tr>
<tr>
<td><code>roll_pointer</code></td>
<td>指向上一个版本的指针（版本链）</td>
</tr>
</tbody></table>
<p>假设我们对一条记录 <code>id=1</code> 更新了两次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最新版本（当前行）</span><br><span class="line">[id=1, name=&#x27;Tom&#x27;, trx_id=15, roll_pointer]  ---&gt;</span><br><span class="line"></span><br><span class="line">旧版本（第一次更新前）</span><br><span class="line">[id=1, name=&#x27;Jack&#x27;, trx_id=11, roll_pointer] ---&gt;</span><br><span class="line"></span><br><span class="line">最旧版本（插入时）</span><br><span class="line">[id=1, name=&#x27;John&#x27;, trx_id=9, roll_pointer]  ---&gt; null</span><br></pre></td></tr></table></figure>

<p>每次更新只在当前行上覆盖 <code>name</code> 和 <code>trx_id</code>，旧数据被保存到 undo log 中，通过 <code>roll_pointer</code> 串成链。</p>
<h4 id="2-Read-View（快照视图）"><a href="#2-Read-View（快照视图）" class="headerlink" title="2.Read View（快照视图）"></a>2.Read View（快照视图）</h4><p>Read View 并不是数据的完整快照，而是一组判断版本可见性的规则，记录了事务视图的一致性边界。</p>
<p>📌 它在 <strong>事务执行第一条语句时</strong>生成（Repeatable Read），或 <strong>每条语句生成（Read Committed）</strong>。</p>
<p>Read View 包含以下信息：</p>
<ul>
<li><code>creator_trx_id</code>：当前事务的 ID</li>
<li><code>min_trx_id</code>：Read View 生成时，系统中最小活跃事务 ID</li>
<li><code>max_trx_id</code>：Read View 生成时，系统中尚未分配的新事务 ID</li>
<li><code>m_ids</code>：当前活跃事务 ID 列表</li>
</ul>
<h4 id="3、版本可见性判断逻辑"><a href="#3、版本可见性判断逻辑" class="headerlink" title="3、版本可见性判断逻辑"></a>3、版本可见性判断逻辑</h4><p>当事务读取记录时，会依据 <code>Read View</code> 来决定当前记录是否可见。逻辑如下：</p>
<ol>
<li>✅ 如果 <code>trx_id == creator_trx_id</code>：是当前事务自己写的 → 可见</li>
<li>✅ 如果 <code>trx_id &lt; min_trx_id</code>：比当前视图早创建 → 可见</li>
<li>❌ 如果 <code>trx_id &gt;= max_trx_id</code>：是视图生成后开始的事务 → 不可见</li>
<li>❓ 如果 <code>trx_id</code> 在 <code>m_ids</code> 中 → 还没提交 → 不可见</li>
<li>✅ 不在 <code>m_ids</code> 中 → 已提交 → 可见</li>
</ol>
<h3 id="3、不同隔离级别下-Read-View-行为"><a href="#3、不同隔离级别下-Read-View-行为" class="headerlink" title="3、不同隔离级别下 Read View 行为"></a>3、不同隔离级别下 Read View 行为</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>Read View 创建时机</th>
<th>行为差异说明</th>
</tr>
</thead>
<tbody><tr>
<td>Read Committed</td>
<td>每次 SQL 执行时</td>
<td>每次读取最新已提交数据版本</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>第一次 SQL 执行时生成一次</td>
<td>后续所有读取使用相同视图，保证一致</td>
</tr>
</tbody></table>
<p>默认情况下，InnoDB 的隔离级别是 <code>Repeatable Read</code>，所以同一事务中读到的数据是<strong>一致的旧快照</strong>，不会看到其他事务中途更新的内容。</p>
<h3 id="4、局限性"><a href="#4、局限性" class="headerlink" title="4、局限性"></a>4、局限性</h3><p>实现的是可重复读的隔离级别。因此，仅能避免脏读、脏写、不可重复读问题，无法避免幻读、读写偏差、丢失更新。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>理解数据库事务</p><p><a href="http://symbol23441.top/2025/04/09/理解数据库事务/">http://symbol23441.top/2025/04/09/理解数据库事务/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Mr.Symbol</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-04-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-04-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/04/17/DB%E7%9A%84%E8%81%9A%E7%B0%87%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88%E5%9F%BA%E4%BA%8EMysql-InnoDB%E5%BC%95%E6%93%8E%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">DB的聚簇与非聚簇索引（基于Mysql InnoDB引擎）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/03/25/C-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><span class="level-item">C++刷题笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、ACID：事务的四大特性"><span class="level-left"><span class="level-item">一、ACID：事务的四大特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-原子性（Atomicity）"><span class="level-left"><span class="level-item">1. 原子性（Atomicity）</span></span></a></li><li><a class="level is-mobile" href="#2-一致性（Consistency）"><span class="level-left"><span class="level-item">2. 一致性（Consistency）</span></span></a></li><li><a class="level is-mobile" href="#3-隔离性（Isolation）"><span class="level-left"><span class="level-item">3. 隔离性（Isolation）</span></span></a></li><li><a class="level is-mobile" href="#4-持久性（Durability）"><span class="level-left"><span class="level-item">4. 持久性（Durability）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、事务隔离级别详解"><span class="level-left"><span class="level-item">二、事务隔离级别详解</span></span></a></li><li><a class="level is-mobile" href="#三、并发问题"><span class="level-left"><span class="level-item">三、并发问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-脏读（Dirty-Read）"><span class="level-left"><span class="level-item">1. 脏读（Dirty Read）</span></span></a></li><li><a class="level is-mobile" href="#2-脏写（Dirty-Write）"><span class="level-left"><span class="level-item">2. 脏写（Dirty Write）</span></span></a></li><li><a class="level is-mobile" href="#3-不可重复读（Non-Repeatable-Read）"><span class="level-left"><span class="level-item">3. 不可重复读（Non-Repeatable Read）</span></span></a></li><li><a class="level is-mobile" href="#4-幻读（Phantom-Read）"><span class="level-left"><span class="level-item">4. 幻读（Phantom Read）</span></span></a></li><li><a class="level is-mobile" href="#5-读偏差（Read-Skew）"><span class="level-left"><span class="level-item">5. 读偏差（Read Skew）</span></span></a></li><li><a class="level is-mobile" href="#6-写偏差（Write-Skew）"><span class="level-left"><span class="level-item">6. 写偏差（Write Skew）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#📋-场景背景："><span class="level-left"><span class="level-item">📋 场景背景：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-丢失更新（Lost-Update）"><span class="level-left"><span class="level-item">7. 丢失更新（Lost Update）</span></span></a></li><li><a class="level is-mobile" href="#8-并发问题总结"><span class="level-left"><span class="level-item">8. 并发问题总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、基于锁的隔离级别实现"><span class="level-left"><span class="level-item">四、基于锁的隔离级别实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、为什么需要锁？"><span class="level-left"><span class="level-item">1、为什么需要锁？</span></span></a></li><li><a class="level is-mobile" href="#2、基础锁类型"><span class="level-left"><span class="level-item">2、基础锁类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#（1）共享锁（S锁，Share-Lock）"><span class="level-left"><span class="level-item">（1）共享锁（S锁，Share Lock）</span></span></a></li><li><a class="level is-mobile" href="#（2）排它锁（X锁，Exclusive-Lock）"><span class="level-left"><span class="level-item">（2）排它锁（X锁，Exclusive Lock）</span></span></a></li><li><a class="level is-mobile" href="#（3）锁兼容关系："><span class="level-left"><span class="level-item">（3）锁兼容关系：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3、两阶段加锁协议（2PL）"><span class="level-left"><span class="level-item">3、两阶段加锁协议（2PL）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#📌-1-基本两阶段加锁（2PL）"><span class="level-left"><span class="level-item">📌 1. 基本两阶段加锁（2PL）</span></span></a></li><li><a class="level is-mobile" href="#📌-2-严格两阶段加锁（Strict-2PL）"><span class="level-left"><span class="level-item">📌 2. 严格两阶段加锁（Strict 2PL）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4、多粒度锁-amp-意向锁（Intention-Lock）"><span class="level-left"><span class="level-item">4、多粒度锁 &amp; 意向锁（Intention Lock）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#✅-多粒度锁？"><span class="level-left"><span class="level-item">✅ 多粒度锁？</span></span></a></li><li><a class="level is-mobile" href="#✅-意向锁的作用"><span class="level-left"><span class="level-item">✅ 意向锁的作用</span></span></a></li><li><a class="level is-mobile" href="#✅-加锁顺序与兼容"><span class="level-left"><span class="level-item">✅  加锁顺序与兼容</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5、解决幻读：间隙锁-amp-Next-Key-Lock"><span class="level-left"><span class="level-item">5、解决幻读：间隙锁 &amp; Next-Key Lock</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#幻读场景："><span class="level-left"><span class="level-item">幻读场景：</span></span></a></li><li><a class="level is-mobile" href="#1-间隙锁（Gap-Lock）"><span class="level-left"><span class="level-item">1. 间隙锁（Gap Lock）</span></span></a></li><li><a class="level is-mobile" href="#2-Next-Key-Lock"><span class="level-left"><span class="level-item">2. Next-Key Lock</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6、并发问题的锁解决方案"><span class="level-left"><span class="level-item">6、并发问题的锁解决方案</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五、MVCC"><span class="level-left"><span class="level-item">五、MVCC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、引入MVCC的动机"><span class="level-left"><span class="level-item">1、引入MVCC的动机</span></span></a></li><li><a class="level is-mobile" href="#2、MVCC-的底层机制"><span class="level-left"><span class="level-item">2、MVCC 的底层机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-版本链（Undo-Log）"><span class="level-left"><span class="level-item">1. 版本链（Undo Log）</span></span></a></li><li><a class="level is-mobile" href="#2-Read-View（快照视图）"><span class="level-left"><span class="level-item">2.Read View（快照视图）</span></span></a></li><li><a class="level is-mobile" href="#3、版本可见性判断逻辑"><span class="level-left"><span class="level-item">3、版本可见性判断逻辑</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3、不同隔离级别下-Read-View-行为"><span class="level-left"><span class="level-item">3、不同隔离级别下 Read View 行为</span></span></a></li><li><a class="level is-mobile" href="#4、局限性"><span class="level-left"><span class="level-item">4、局限性</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Mr.SymbolのBlog</a><p class="is-size-7"><span>&copy; 2025 Mr.Symbol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>