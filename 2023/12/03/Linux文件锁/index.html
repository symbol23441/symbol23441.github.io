<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux文件锁 - Mr.SymbolのBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Mr.Symbolのblog"><meta name="msapplication-TileImage" content="/img/s2.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Mr.Symbolのblog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1、linux文件锁简介Linux中软件、硬件资源都是文件（一切皆文件），文件在多用户环境中是可共享的。 文件锁是用于解决资源的共享使用的一种机制：当多个用户需要共享一个文件时，Linux通常采用的方法是给文件上锁，来避免共享的资源产生竞争的状态。 文件锁包括劝告锁和强制性锁： 劝告锁：要求每个使用上锁文件的进程都要检查是否有锁存在，并且尊重已有的锁。在一般情况下，内核和系统都不使用建议性锁，它们"><meta property="og:type" content="blog"><meta property="og:title" content="Linux文件锁"><meta property="og:url" content="http://symbol23441.top/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/"><meta property="og:site_name" content="Mr.SymbolのBlog"><meta property="og:description" content="1、linux文件锁简介Linux中软件、硬件资源都是文件（一切皆文件），文件在多用户环境中是可共享的。 文件锁是用于解决资源的共享使用的一种机制：当多个用户需要共享一个文件时，Linux通常采用的方法是给文件上锁，来避免共享的资源产生竞争的状态。 文件锁包括劝告锁和强制性锁： 劝告锁：要求每个使用上锁文件的进程都要检查是否有锁存在，并且尊重已有的锁。在一般情况下，内核和系统都不使用建议性锁，它们"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://symbol23441.top/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/v2-34f2c8bd2e45f8b60c68efe2279aba6e_1440w.webp"><meta property="og:image" content="http://symbol23441.top/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/v2-48f1a52773bd92dd9234de760c5c45ce_1440w.webp"><meta property="article:published_time" content="2023-12-03T09:24:28.000Z"><meta property="article:modified_time" content="2023-12-03T09:24:28.000Z"><meta property="article:author" content="Mr.Symbol"><meta property="article:tag" content="文件锁"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/v2-34f2c8bd2e45f8b60c68efe2279aba6e_1440w.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://symbol23441.top/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/"},"headline":"Linux文件锁","image":["http://symbol23441.top/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/v2-34f2c8bd2e45f8b60c68efe2279aba6e_1440w.webp","http://symbol23441.top/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/v2-48f1a52773bd92dd9234de760c5c45ce_1440w.webp"],"datePublished":"2023-12-03T09:24:28.000Z","dateModified":"2023-12-03T09:24:28.000Z","author":{"@type":"Person","name":"Mr.Symbol"},"publisher":{"@type":"Organization","name":"Mr.SymbolのBlog","logo":{"@type":"ImageObject","url":{"text":"Mr.SymbolのBlog"}}},"description":"1、linux文件锁简介Linux中软件、硬件资源都是文件（一切皆文件），文件在多用户环境中是可共享的。 文件锁是用于解决资源的共享使用的一种机制：当多个用户需要共享一个文件时，Linux通常采用的方法是给文件上锁，来避免共享的资源产生竞争的状态。 文件锁包括劝告锁和强制性锁： 劝告锁：要求每个使用上锁文件的进程都要检查是否有锁存在，并且尊重已有的锁。在一般情况下，内核和系统都不使用建议性锁，它们"}</script><link rel="canonical" href="http://symbol23441.top/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/"><link rel="icon" href="/img/s2.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Mr.SymbolのBlog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-03T09:24:28.000Z" title="12/3/2023, 5:24:28 PM">2023-12-03</time>发表</span><span class="level-item"><time dateTime="2023-12-03T09:24:28.000Z" title="12/3/2023, 5:24:28 PM">2023-12-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux-C%E7%BC%96%E7%A8%8B/">Linux C编程</a></span><span class="level-item">16 分钟读完 (大约2389个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Linux文件锁</h1><div class="content"><h1 id="1、linux文件锁简介"><a href="#1、linux文件锁简介" class="headerlink" title="1、linux文件锁简介"></a>1、linux文件锁简介</h1><p>Linux中软件、硬件资源都是文件（一切皆文件），文件在多用户环境中是可共享的。</p>
<p>文件锁是用于解决资源的共享使用的一种机制：当多个用户需要共享一个文件时，Linux通常采用的方法是给文件上锁，来避免共享的资源产生竞争的状态。</p>
<p>文件锁包括劝告锁和强制性锁：</p>
<p>劝告锁：要求每个使用上锁文件的进程都要检查是否有锁存在，并且尊重已有的锁。在一般情况下，内核和系统都不使用建议性锁，它们依靠程序员遵守这个规定。</p>
<p>强制锁：是由内核执行的锁，当一个文件被上锁进行写入操作的时候，内核将阻止其他任何文件对其进行读写操作。采用强制性锁对性能的影响很大，每次读写操作都必须检查是否有锁存在。 在Linux中，实现文件上锁的函数有lockf()和fcntl()。fcntl()不仅可以施加建议性锁，还可以施加强制锁。 fcntl()还能对文件的某一记录上锁，也就是记录锁。</p>
<p>劝告锁的加锁规则：</p>
<p><img src="/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/v2-34f2c8bd2e45f8b60c68efe2279aba6e_1440w.webp" alt="img"></p>
<p>强制锁的加锁规则：</p>
<p><img src="/2023/12/03/Linux%E6%96%87%E4%BB%B6%E9%94%81/v2-48f1a52773bd92dd9234de760c5c45ce_1440w.webp" alt="img"></p>
<p>记录锁又可分为<strong>读取锁和写入锁</strong>，其中读取锁又称为共享锁，它能够使多个进程都能在文件的同一部分建立读取锁。（上面两个图也可以看出）</p>
<p><strong>写入锁又称为排斥锁，在任何时刻只能有一个进程在文件的某个部分建立写入锁</strong>。</p>
<p>在文件的同一部分不能同时建立读取锁和写入</p>
<span id="more"></span>

<h1 id="2、相关函数"><a href="#2、相关函数" class="headerlink" title="2、相关函数"></a>2、相关函数</h1><p>目前跟文件加锁相关的系统调用主要有两个： <strong>flock与fcntl,</strong> 二者在应用范围方面也存在着一些差别，早起的flock函数只能处理劝告锁，在Linux 2.6版本中将其功能扩充至强制锁，另外 <strong>flock函数只能对整个文件加锁，不能加记录锁，而fcntl函数则不仅完全支持加劝告锁与强制锁，还支持记录锁，另外因为它符合POSIX标准，具有很好的可移植性</strong>。</p>
<p>注意点：</p>
<ol>
<li>在给文件加锁之前,一定要保证文件<strong>以相应的访问模式打开</strong>。例如要对一个文件加上共享锁,一定要首先按读模式打开文件,若要给文件加上排他锁,则首先要按写模式打开对应文件若想加两种锁，则需要按读写模式打开.</li>
<li>锁的释放：锁与进程和文件紧密相连，若<strong>进程终止</strong>，则有它创建的所有锁将会自动释放掉；若<strong>关闭文件描述符</strong>，则进程由此描述符引用的文件上的任何锁也将会被释放；</li>
<li>由fork产生的子进程不会继承父进程的文件锁；</li>
</ol>
<h2 id="1-flock"><a href="#1-flock" class="headerlink" title="1 flock"></a>1 flock</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span></span></span><br></pre></td></tr></table></figure>

<p>相对于fcntl函数，flock显得更加简单，因为所加的锁会影响整个文件，其中operation参数规定了所加锁的类型：</p>
<p>LOCK_SH:表示加共享锁</p>
<p>LOCK_EX：表示排他锁</p>
<p>LOCK_UN：表示释放锁</p>
<p>LOCK_MAND：表示强制锁</p>
<h2 id="2-fcntl"><a href="#2-fcntl" class="headerlink" title="2 fcntl"></a>2 fcntl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *flockptr */</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>与锁相关的 cmd 为 F_SETLK、F_SETLKW、F_GETLK，第三个参数 flockptr 是一个 struct flock 结构体指针。使用 fcntl()实现文件锁功能与 flock()有两个比较大的区别：</p>
<ul>
<li><p>flock()仅支持对整个文件进行加锁/解锁；而 fcntl()可以对文件的某个区域（某部分内容）进行加锁 /解锁，可以精确到某一个字节数据。</p>
</li>
<li><p>flock()仅支持建议性锁类型；而 fcntl()可支持建议性锁和强制性锁两种类型。</p>
</li>
</ul>
<h3 id="1、struct-flock"><a href="#1、struct-flock" class="headerlink" title="1、struct flock"></a>1、struct flock</h3><p>我们先来看看 struct flock 结构体，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">short</span> l_type; <span class="comment">/* Type of lock: F_RDLCK,F_WRLCK, F_UNLCK */</span></span><br><span class="line"> <span class="keyword">short</span> l_whence; <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line"> <span class="keyword">off_t</span> l_start; <span class="comment">/* Starting offset for lock */</span></span><br><span class="line"> <span class="keyword">off_t</span> l_len; <span class="comment">/* length, in bytes; 0 means lock to EOF */</span></span><br><span class="line"> <span class="keyword">pid_t</span> l_pid; <span class="comment">/* PID of process blocking our lock(set by F_GETLK and F_OFD_GETLK) */</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对 struct flock 结构体说明如下：</p>
<ul>
<li> l_type：所希望的锁类型，可以设置为 F_RDLCK、F_WRLCK 和 F_UNLCK 三种类型之一，F_RDLCK 表示共享性质的读锁，F_WRLCK 表示独占性质的写锁，F_UNLCK 表示解锁一个区域。</li>
<li>l_whence 和 l_start：这两个变量用于指定要加锁或解锁区域的起始字节偏移量，与lseek()函数中的 offset 和 whence 参数相同，这里不再重述。</li>
<li> l_len：需要加锁或解锁区域的字节长度。</li>
<li> l_pid：一个 pid，指向一个进程，表示该进程持有的锁能阻塞当前进程，当 cmd=F_GETLK 时有效。</li>
</ul>
<p>以上便是对 struct flock 结构体各成员变量的简单介绍，对于加锁和解锁区域的说明，还需要注意以下几项规则：</p>
<p>锁区域可以在当前文件末尾处开始或者越过末尾处开始，但是不能在文件起始位置之前开始。<br>若参数 l_len 设置为 0，表示将锁区域扩大到最大范围，也就是说从锁区域的起始位置开始，到文 件的最大偏移量处（也就是文件末尾）都处于锁区域范围内。而且是动态的，这意味着不管向该文件追加写了多少数据，它们都处于锁区域范围，起始位置可以是文件的任意位置。<br>如果我们需要对整个文件加锁，可以将 l_whence 和 l_start 设置为指向文件的起始位置，并且指定参数 l_len 等于 0。</p>
<h3 id="2、cmd"><a href="#2、cmd" class="headerlink" title="2、cmd"></a>2、cmd</h3><p>fcntl函数专门用来对文件描述符操作的，具体的操作行为取决于cmd值，与本文文件锁相关的cmd值主要有：</p>
<ul>
<li>F_GETLK：获取文件锁</li>
</ul>
<p>这种用法一般用于测试，测试调用进程对文件加一把由参数 flockptr 指向的 struct flock 对象所描述的锁是否会加锁成功。如果加锁不成功，意味着该文件的这部分区域已经存在一把锁， 并且由另一进程所持有，并且调用进程加的锁与现有锁之间存在排斥关系，现有锁会阻止调用进程想要加的锁，并且现有锁的信息将会重写参数 flockptr 指向的对象信息。如果不存在这种情况，也就是说 flockptr 指向的 struct flock 对象所描述的锁会加锁成功，则除了将 struct flock 对象的 l_type 修改为 F_UNLCK 之外，结构体中的其它信息保持不变。</p>
<ul>
<li>F_SETLK：设置文件锁（非阻塞版）</li>
</ul>
<p>对文件添加由 flockptr 指向的 struct flock 对象所描述的锁。譬如试图对文件的某一区域加读锁（l_type 等于 F_RDLCK）或写锁（l_type 等于 F_WRLCK），如果加锁失败，那么 fcntl() 将立即出错返回，此时将 errno 设置为 EACCES 或 EAGAIN。也可用于清除由 flockptr 指向的 struct flock 对象所描述的锁（l_type 等于 F_UNLCK）。</p>
<ul>
<li>F_SETLKW：设置文件锁（阻塞版）</li>
</ul>
<p>F_GETLK 命令一般很少用，事先用 F_GETLK 命令测试是否能够对文件加锁，然后再用 F_SETLK或F_SETLKW 命令对文件加锁，但这两者并不是原子操作，所以即使测试结果表明可以加锁成功，但是在使 用 F_SETLK 或 F_SETLKW 命令对文件加锁之前也有可能被其它进程锁住。</p>
<h1 id="3、代码示例"><a href="#3、代码示例" class="headerlink" title="3、代码示例"></a>3、代码示例</h1><h2 id="1、flock"><a href="#1、flock" class="headerlink" title="1、flock"></a>1、flock</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_fun</span><span class="params">(<span class="keyword">void</span> *pth_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line"> </span><br><span class="line">	fd = open(<span class="string">&quot;./hello&quot;</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)  print_err(<span class="string">&quot;./hello&quot;</span>, __LINE__, errno); </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flock(fd, LOCK_EX);</span><br><span class="line">		write(fd, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">		write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">		flock(fd, LOCK_UN);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line"> </span><br><span class="line">	fd = open(<span class="string">&quot;./hello&quot;</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)  print_err(<span class="string">&quot;./hello&quot;</span>, __LINE__, errno); </span><br><span class="line"> </span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, pth_fun, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) print_err(<span class="string">&quot;pthread_create fail&quot;</span>, __LINE__, ret);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flock(fd, LOCK_EX);</span><br><span class="line">		write(fd, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">		write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">		flock(fd, LOCK_UN);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="2、fcntl"><a href="#2、fcntl" class="headerlink" title="2、fcntl"></a>2、fcntl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">/* 校验传参 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != argc) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对文件加锁 */</span></span><br><span class="line">    lock.l_type = F_WRLCK; <span class="comment">//独占性写锁</span></span><br><span class="line">    lock.l_whence = SEEK_SET; <span class="comment">//文件头部</span></span><br><span class="line">    lock.l_start = <span class="number">0</span>; <span class="comment">//偏移量为 0</span></span><br><span class="line">    lock.l_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fcntl(fd, F_SETLK, &amp;lock)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;加锁失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;对文件加锁成功!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 对文件进行写操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; write(fd, buf, <span class="built_in">strlen</span>(buf))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 解锁 */</span></span><br><span class="line">    lock.l_type = F_UNLCK; <span class="comment">//解锁</span></span><br><span class="line">    fcntl(fd, F_SETLK, &amp;lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 退出 */</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>Linux文件锁</p><p><a href="http://symbol23441.top/2023/12/03/Linux文件锁/">http://symbol23441.top/2023/12/03/Linux文件锁/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Mr.Symbol</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-12-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-12-03</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%96%87%E4%BB%B6%E9%94%81/">文件锁</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/12/06/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Linux基本操作</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/12/03/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"><span class="level-item">共享内存</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1、linux文件锁简介"><span class="level-left"><span class="level-item">1、linux文件锁简介</span></span></a></li><li><a class="level is-mobile" href="#2、相关函数"><span class="level-left"><span class="level-item">2、相关函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-flock"><span class="level-left"><span class="level-item">1 flock</span></span></a></li><li><a class="level is-mobile" href="#2-fcntl"><span class="level-left"><span class="level-item">2 fcntl</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、struct-flock"><span class="level-left"><span class="level-item">1、struct flock</span></span></a></li><li><a class="level is-mobile" href="#2、cmd"><span class="level-left"><span class="level-item">2、cmd</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#3、代码示例"><span class="level-left"><span class="level-item">3、代码示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1、flock"><span class="level-left"><span class="level-item">1、flock</span></span></a></li><li><a class="level is-mobile" href="#2、fcntl"><span class="level-left"><span class="level-item">2、fcntl</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Mr.SymbolのBlog</a><p class="is-size-7"><span>&copy; 2025 Mr.Symbol</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>